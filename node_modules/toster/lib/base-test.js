'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseTest = undefined;

var _emitter = require('./emitter');

var _testStatus = require('./test-status');

var _util = require('./util');

class BaseTest extends _emitter.Emitter {
  constructor() {
    let opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    super();

    this._title = opts.title || '';

    this._initialStatus = opts.initialStatus || _testStatus.NOT_EXECUTED;

    this._beforeCallbacks = [];
    this._afterCallbacks = [];

    this.reset();
  }

  _setStatus(status) {
    this._status = status;
  }

  _setStatusAsync(status) {
    this._setStatus(status);
    return Promise.resolve(status);
  }

  reset() {
    this._status = this._initialStatus;
    this._state = {};
  }

  addBeforeCallback(f) {
    this._beforeCallbacks.push(f);
    return this;
  }

  addAfterCallback(f) {
    this._afterCallbacks.push(f);
    return this;
  }

  _onSkip() {
    return Promise.resolve();
  }

  _run() {
    return Promise.resolve(this._status);
  }

  _runAll() {
    if (this._initialStatus === _testStatus.SKIP) {
      return this._onSkip();
    } else {
      return (0, _util.runCallbacks)(this._beforeCallbacks, this._state).then(() => this._run()).then(() => (0, _util.runCallbacks)(this._afterCallbacks, this._state));
    }
  }

  run() {
    this.emit('start', this);
    let start = Date.now();

    return this._runAll().catch(err => this._setStatusAsync(new _testStatus.TestFailStatus(err))).then(() => {
      this._status.duration = Date.now() - start;

      this.emit('end', this);
      return this._status;
    });
  }

  status() {
    return this._status;
  }

  initialStatus() {
    return this._initialStatus;
  }

  title() {
    return this._title;
  }

  toJSON() {
    return {
      status: this._status,
      title: this._title
    };
  }
}
exports.BaseTest = BaseTest;