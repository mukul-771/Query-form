'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Suite = undefined;

var _baseTest = require('./base-test');

var _testStatus = require('./test-status');

var _util = require('./util');

class Suite extends _baseTest.BaseTest {
  constructor() {
    let opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    super(opts);

    this._tests = [];
    this._index = 0;

    this._beforeTestCallbacks = [];
    this._afterTestCallbacks = [];
  }

  add(t) {
    this._beforeTestCallbacks.forEach(f => t.addBeforeCallback(f));
    this._afterTestCallbacks.forEach(f => t.addAfterCallback(f));

    this._tests.push(t);
    return this;
  }

  addBeforeTestCallback(f) {
    this._beforeTestCallbacks.push(f);
    return this;
  }

  addAfterTestCallback(f) {
    this._afterTestCallbacks.push(f);
    return this;
  }

  _onSkip() {
    // run tests even if skipped to emit events on tests
    return this._run();
  }

  _run() {
    return (0, _util.callFunction)(this._tests, 'run').then(() => {
      let stat = this._tests.reduce((acc, t) => {
        let statusName = t.status().name;
        acc[statusName] = (acc[statusName] || 0) + 1;
        return acc;
      }, {});

      let statuses = Object.keys(stat);
      if (statuses.length === 0) return this._setStatusAsync(_testStatus.SKIP);

      if ((stat.FAIL || 0) > 0 || (stat.TIMEOUT || 0) > 0) return this._setStatusAsync(_testStatus.SUITE_FAIL);

      if (statuses.length === 1) {
        return this._setStatusAsync(this._tests[0].status());
      }

      return this._setStatusAsync(_testStatus.SUCCESS);
    });
  }
}
exports.Suite = Suite;